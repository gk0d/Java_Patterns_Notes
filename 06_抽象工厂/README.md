- [作用](#作用)
- [思考](#思考)
- [解决](#解决)
- [结构](#结构)
- [应用场景](#应用场景)


# 作用
创建一系列相关的对象， 而无需指定其具体类。
# 思考
正在开发一款家具商店模拟器，代码中包括一些类：
1. 一系列相关产品， 例如 椅子Chair 、沙发Sofa和 咖啡桌CoffeeTable
2. 系列产品的不同变体。 例如， 你可以使用 现代Modern 、 维多利亚Victorian 、装饰风艺术ArtDeco等风格生成 椅子，沙发和咖啡桌

需要设法单独生成每件家具对象，这样才能确保其风格一致

不希望在添加新产品或新风格时修改已有代码。 家具供应商对于产品目录的更新非常频繁， 你不会想在每次更新时都去修改核心代码的


# 解决
抽象工厂模式建议为系列中的每件产品明确声明接口 （例如椅子、 沙发或咖啡桌）。确保所有产品变体都继承这些接口。 例如， 所有风格的椅子都实现 椅子接口； 所有风格的咖啡桌都实现 咖啡桌接口， 以此类推

![image](https://user-images.githubusercontent.com/83335903/224487290-23782282-f5eb-4afd-93ff-9d5e2a4aee46.png)


接下来，声明抽象工厂——包含系列中所有产品构造方法的接口，例如 createChair创建椅子 、createSofa创建沙发和 createCoffeeTable创建咖啡桌 。 这些方法必须返回抽象产品类型， 即我们之前抽取的那些接口：椅子 ，沙发和 咖啡桌等等。

![image](https://user-images.githubusercontent.com/83335903/224487361-2b5310cd-007d-4200-9f00-2201a1abcf7e.png)

对于系列产品的每个变体， 我们都将基于 抽象工厂接口创建不同的工厂类。 每个工厂类都只能返回特定类别的产品，例如， 现代家具工厂ModernFurnitureFactory只能创建 现代椅子ModernChair 、现代沙发ModernSofa和 现代咖啡桌ModernCoffeeTable对象。

客户端代码可以通过相应的抽象接口调用工厂和产品类。 你无需修改实际客户端代码， 就能更改传递给客户端的工厂类， 也能更改客户端代码接收的产品变体


# 结构

![image](https://user-images.githubusercontent.com/83335903/224487408-26013478-e94a-4c7a-93ee-5cd81dfbafbe.png)

1. 抽象产品(Abstract Product)为构成系列产品的一组不同但相关的产品声明接口.
2. 具体产品(Concrete Product)是抽象产品的多种不同类型实现。 所有变体 （维多利亚/现代） 都必须实现相应的抽象产品(椅子/沙发)
3. 抽象工厂(Abstract Factory)接口声明了一组创建各种抽象产品的方法
4. 具体工厂(Concrete Factory)实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体



# 应用场景
如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂

 如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式



