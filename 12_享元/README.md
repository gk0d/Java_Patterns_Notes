
- [思考](#思考)
- [解决](#解决)

- [结构](#结构)

- [应用场景](#应用场景)
- [实现](#实现)



# 思考
开发了一款简单的游戏：实现了一个真实的粒子系统， 大量的子弹、导弹和爆炸弹片会在整个地图上穿行。游戏在你的电脑上完美运行， 但是你的朋友却无法长时间进行游戏。导致游戏崩溃的原因是内存容量不足。

真正的问题与粒子系统有关。 每个粒子都由包含完整数据的独立对象来表示。 当玩家在游戏中进入高潮后的某一时刻， 游戏将无法在剩余内存中载入新建粒子， 于是程序就崩溃了

![image](https://user-images.githubusercontent.com/83335903/224526522-80894770-a9a8-4493-adba-6abf370852a1.png)




# 解决
观察粒子`Particle`类， 你可能会注意到颜色`color`和图 `sprite`这两个成员变量所消耗的内存要比其他变量多得多。 更糟糕的是， 对于所有的粒子来说， 这两个成员变量所存储的数据几乎完全一样 （比如所有子弹的颜色和图都一样）

![image](https://user-images.githubusercontent.com/83335903/224526562-bedd712d-5550-47a8-9149-ebaa3e616352.png)

每个粒子的另一些状态(坐标，移动矢量和速度）是不同的，这些数据代表粒子在存续期间不断变化的情景， 但每个粒子的颜色和精灵图则会保持不变。

对象的常量数据通常被称为`内在状态`， 其位于对象中， 其他对象只能读取但不能修改其数值。 而对象的其他状态常常能被其他对象 “从外部” 改变， 因此被称为`外在状态`。

享元模式建议不在对象中存储`外在状态`， 而是将其传递给依赖于它的一个特殊方法。 程序只在对象中保存内在状态， 以方便在不同情景下重用.

![image](https://user-images.githubusercontent.com/83335903/224526637-3651057f-9631-4a1a-8c16-ec38e50ee7d0.png)

我们回到游戏中。 假如能从粒子类中抽出外在状态， 那么我们只需三个不同的对象 （子弹、 导弹和弹片） 就能表示游戏中的所有粒子。 你现在很可能已经猜到了， 我们将这样一个仅存储内在状态的对象称为享元



# 结构

![image](https://user-images.githubusercontent.com/83335903/224526667-a96e0f8f-d6f1-486d-a01f-9528b5a97d03.png)

1. 享元模式只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。

2. 享元 （Flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。

3. 情景 （Context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。

4. 通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。

5. 客户端 （Client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。

6. 享元工厂 （Flyweight Factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。



# 应用场景
仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。

# 实现
1. 将需要改写为享元的类成员变量拆分为两个部分：
   1. 内在状态： 包含不变的、 可在许多对象中重复使用的数据的成员变量。
   2. 外在状态： 包含每个对象各自不同的情景数据的成员变量
2. 保留类中表示内在状态的成员变量， 并将其属性设置为不可修改。 这些变量仅可在构造函数中获得初始数值。

3. 找到所有使用外在状态成员变量的方法， 为在方法中所用的每个成员变量新建一个参数， 并使用该参数代替成员变量。

4. 你可以有选择地创建工厂类来管理享元缓存池， 它负责在新建享元时检查已有的享元。 如果选择使用工厂， 客户端就只能通过工厂来请求享元， 它们需要将享元的内在状态作为参数传递给工厂。

5. 客户端必须存储和计算外在状态 （情景） 的数值， 因为只有这样才能调用享元对象的方法。 为了使用方便， 外在状态和引用享元的成员变量可以移动到单独的情景类中。


