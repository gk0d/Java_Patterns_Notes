- [作用](#作用)
- [思考](#思考)
- [解决](#解决)
- [结构](#结构)
- [应用场景](#应用场景)
- [实现](#实现)
- [优缺点](#优缺点)

# 作用
在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型

# 思考
假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为`卡车`的类中。
一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能
代码问题该如何处理呢？ 目前， 大部分代码都与`卡车类`相关。 在程序中添加 `轮船类`需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改
# 解决
使用特殊的工厂方法来代替对象构造函数的调用(new),对象仍将通过 new运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”

![image](https://user-images.githubusercontent.com/83335903/224468895-434122a0-b37e-452e-a2eb-4ace5bc813f5.png)

有一点需要注意:仅当这些产品具有共同的基类或者接口时， 子类才能返回不同类型的产品， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。

![image](https://user-images.githubusercontent.com/83335903/224468909-dfd5a8a4-cb7c-477f-870b-4a9fa428b503.png)


举例来说， `卡车Truck`和 `轮船Ship`类都必须实现 运输`Transport`接口， 该接口声明了一个名为 `deliver`交付的方法。 每个类都将以不同的方式实现该方法： 卡车走陆路交付货物， 轮船走海路交付货物。 陆路运输`RoadLogistics`类中的工厂方法返回卡车对象， 而 海路运输`SeaLogistics`类则返回轮船对象


# 结构

![image](https://user-images.githubusercontent.com/83335903/224468954-5eef2fe6-799f-4f33-8f31-b1cd8073467a.png)

1. 产品 （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。
2. 具体产品 （Concrete Products） 是产品接口的不同实现。
3. 创建者 （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。
4. 具体创建者 （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。


# 实例
背景：小华有一间工厂（仅生产A类产品）；随着客户需求的变化，客户需要生产B类产品；
冲突：改变原有工厂的配置和变化非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本；
解决方案：小成决定置办`分厂B`来生产B类产品------》即工厂方法模式
首先创建抽象工厂类，定义具体工厂的公共接口
```
abstract class Factory{
    public abstract Product Manufacture();
}
```
创建抽象产品类 ，定义具体产品的公共接口
```
abstract class Product{
    public abstract void Show();
}
```
创建具体产品类（继承抽象产品类）， 定义生产的具体产品
```
//具体产品A类
class  ProductA extends  Product{
    @Override
    public void Show() {
        System.out.println("生产出了产品A");
    }
}
 
//具体产品B类
class  ProductB extends  Product{
 
    @Override
    public void Show() {
        System.out.println("生产出了产品B");
    }
}
```
创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；
```
//工厂A类 - 生产A类产品
class  FactoryA extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductA();
    }
}
 
//工厂B类 - 生产B类产品
class  FactoryB extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductB();
    }
}
```
外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例
```
//生产工作流程
public class FactoryPattern {
    public static void main(String[] args){
        //客户要产品A
        FactoryA mFactoryA = new FactoryA();
        mFactoryA.Manufacture().Show();
 
        //客户要产品B
        FactoryB mFactoryB = new FactoryB();
        mFactoryB.Manufacture().Show();
    }
}
```


# 应用场景
编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。
工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。

例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。


# 实现
1. 让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。

2. 在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。

3.在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。

4. 为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。
如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。

例如， 设想你有以下一些层次结构的类。 基类 邮件及其子类 航空邮件和 陆路邮件 ； 运输及其子类 飞机, 卡车和 火车 。 航空邮件仅使用 飞机对象， 而 陆路邮件则会同时使用 卡车和 火车对象。 你可以编写一个新的子类 （例如 火车邮件 ） 来处理这两种情况， 但是还有其他可选的方案。 客户端代码可以给 陆路邮件类传递一个参数， 用于控制其希望获得的产品。

如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽象类。 如果基础工厂方法中还有其他语句， 你可以将其设置为该方法的默认行为

# 优缺点
你可以避免创建者和具体产品之间的紧密耦合。
单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。
开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。

应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。
