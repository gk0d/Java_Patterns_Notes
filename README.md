# Java_Patterns_Notes
学习Java设计模式的笔记，大有收获。
# UML类图
其中有大量的UML类图，所以先学习下UML类图
https://github.com/gk0d/Java_Patterns_Notes/blob/main/00_UML%E7%B1%BB%E5%9B%BE%E5%92%8C%E6%97%B6%E5%BA%8F%E5%9B%BE/README.md
# 参考项目
- https://refactoringguru.cn/design-patterns //非常推荐，其中的例子很实用
- https://github.com/youlookwhat/DesignPattern //举的实例很贴近显示，便于理解
- https://design-patterns.readthedocs.io/zh_CN/latest/index.html
------
- [模式小结](#模式小结)
  - [1.单例](#1单例)
  - [2.原型](#2原型)
  - [3.工厂方法](#3工厂方法)
  - [4.生成器](#4生成器)
  - [5.抽象工厂](#5抽象工厂)
  - [6.适配器](#6适配器)
  - [7.桥接](#7桥接)
  - [8.组合](#8组合)
  - [9.装饰](#9装饰)
  - [10.外观](#10外观)
  - [11.享元](#11享元)
  - [12.代理](#12代理)
  - [13.责任链](#13责任链)
  - [14.命令](#14命令)
  - [15.迭代器](#15迭代器)
  - [16.中介者](#16中介者)
  - [17.备忘录](#17备忘录)
  - [18.观察者](#18观察者)
  - [19.状态](#19状态)
  - [20.策略](#20策略)
  - [21.模板](#21模板)
  - [22.访问者](#22访问者)

# 模式小结
## 1.单例
>单例模式主要是为了避免因为创建了多个实例造成资源的浪费，且多个实例由于多次调用容易导致结果出现错误，而使用单例模式能够保证整个应用中有且只有一个实例。

详细：https://github.com/gk0d/Java_Patterns_Notes/tree/main/01_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F
## 2.原型
>原型模式是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

详细：
https://github.com/gk0d/Java_Patterns_Notes/blob/main/02_%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/README.md

## 3.工厂方法
>在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

详细：
https://github.com/gk0d/Java_Patterns_Notes/blob/main/03_%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/README.md

## 4.生成器
>生成器模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/04_%E7%94%9F%E6%88%90%E5%99%A8

## 5.抽象工厂
>能创建一系列相关的对象， 而无需指定其具体类。

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/06_%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82

## 6.适配器
>定义：将一个类的接口转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以相互合作。这个定义还好，说适配器的功能就是把一个接口转成另一个接口。

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/07_%E9%80%82%E9%85%8D%E5%99%A8

## 7.桥接
>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。
- 主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/08_%E6%A1%A5%E6%8E%A5

## 8.组合
> 又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。
- 主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/09_%E7%BB%84%E5%90%88

## 9.装饰
>装饰者模式：若要扩展功能，装饰者提供了比集成更有弹性的替代方案，动态地将责任附加到对象上。

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/10_%E8%A3%85%E9%A5%B0

## 10.外观
>提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。其实就是为了方便客户的使用，把一群操作，封装成一个方法。

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/11_%E5%A4%96%E8%A7%82
## 11.享元
>主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/12_%E4%BA%AB%E5%85%83

## 12.代理
>一个类代表另一个类的功能。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。可以理解为内存中没有这个对象就创建，有就直接返回这个对象。
- 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/13_%E4%BB%A3%E7%90%86

## 13.责任链
>责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

- 主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。


详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/14_%E8%B4%A3%E4%BB%BB%E9%93%BE

## 14.命令
>它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/15_%E5%91%BD%E4%BB%A4
## 15.迭代器
>Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。迭代器模式属于行为型模式。

- 主要解决：不同的方式来遍历整个整合对象。

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/16_%E8%BF%AD%E4%BB%A3%E5%99%A8

## 16.中介者
>用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。
- 主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。


详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/17_%E4%B8%AD%E4%BB%8B%E8%80%85

## 17.备忘录
>保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。

- 主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/18_%E5%A4%87%E5%BF%98%E5%BD%95

## 18.观察者
>定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/19_%E8%A7%82%E5%AF%9F%E8%80%85

## 19.状态
>当对象的内部状态改变时，它的行为跟随状态的改变而改变了，看起来好像重新初始化了一个类似的。

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/20_%E7%8A%B6%E6%80%81
## 20.策略
>策略模式：定义了算法族，分别封装起来，让它们之间可相互替换，此模式让算法的变化独立于使用算法的客户。
详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/21_%E7%AD%96%E7%95%A5
## 21.模板
>定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/21_%E7%AD%96%E7%95%A5
## 22.访问者
>在访问者模式中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。

- 主要解决：稳定的数据结构和易变的操作耦合问题

详细：
https://github.com/gk0d/Java_Patterns_Notes/tree/main/23_%E8%AE%BF%E9%97%AE%E8%80%85
