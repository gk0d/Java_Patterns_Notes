- [作用](#作用)
- [思考](#思考)
- [解决](#解决)
- [结构](#结构)
- [java伪代码](#java伪代码)
- [应用场景](#应用场景)
- [实现](#实现)
- [优缺点](#优缺点)


# 作用
能够分步骤创建复杂对象。 它的创建过程和使用过程要分开。对于对象的使用者来说，我只需要告诉创建者我需要使用这个复杂对象，至于这个复杂对象是怎么创建的，不关我事 (ps：有点渣男的味道)

# 思考
有一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中； 甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置

![image](https://user-images.githubusercontent.com/83335903/224481926-cc845ccc-cb02-4c73-82cc-e21e4fea4f49.png)

如何创建一个`房屋House`对象。 建造一栋简单的房屋， 首先需要建造四面墙和地板， 安装房门和一套窗户， 然后再建造一个屋顶。 但是如果想要一栋更宽敞更明亮的房屋， 还要有院子和其他设施 （例如暖气、 排水和供电设备）， 那又该怎么办呢？

最简单的方法是扩展房屋基类， 然后创建一系列涵盖所有参数组合的子类。 但最终你将面对相当数量的子类。 任何新增的参数 （例如门廊类型） 都会让这个层次结构更加复杂。

另一种方法则无需生成子类。 你可以在房屋基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。 这种方法确实可以避免生成子类， 但它却会造成另外一个问题。

![image](https://user-images.githubusercontent.com/83335903/224482051-12d6946e-0c6e-4952-bff1-803451348b46.png)

通常情况下， 绝大部分的参数都没有使用， 这使得对于构造函数的调用十分不简洁.

# 解决
生成器模式建议将`对象构造代码从产品类`中抽取出来， 并将其放在一个名为生成器的独立对象中。

![image](https://user-images.githubusercontent.com/83335903/224482083-cf05c357-f490-4f8e-8c85-806cf2fbbb7d.png)

该模式会将对象构造过程划分为一组步骤， 比如 `buildWalls创建墙壁`和 `buildDoor创建房门`创建房门等。 每次创建对象时， 你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。

当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。

在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。

进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现

严格来说，程序中并不一定需要主管类。 客户端代码可直接以特定顺序调用创建步骤。 不过， 主管类中非常适合放入各种例行构造流程， 以便在程序中反复使用。

此外， 对于客户端代码来说， 主管类完全隐藏了产品构造细节。 客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果


# 结构

![image](https://user-images.githubusercontent.com/83335903/224482172-0bb942f9-6f0c-4ea7-b6a3-072d51fe91c0.png)

1. 生成器 （Builder） 接口声明在所有类型生成器中通用的产品构造步骤
2. 具体生成器 （Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。
3. 产品 （Products） 是最终生成的对象
4. 主管 （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。
5. 客户端 （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。



# java伪代码
下例演示了如何复用相同的对象构造代码来生成不同类型的产品——例如汽车 （Car）——及其相应的使用手册 （Manual）

![image](https://user-images.githubusercontent.com/83335903/224482339-0ec1774d-0db6-4275-bc1c-d67bd55a5314.png)

汽车是一个复杂对象，别在汽车类中塞入一个巨型构造函数， 而是将汽车组装代码抽取到单独的汽车生成器类中。 该类中有一组方法可用来配置汽车的各种部件。

如果客户端代码需要组装一辆与众不同的汽车， 它可以直接调用生成器。 或者， 客户端将组装工作委托给主管类， 因为主管类知道如何使用生成器制造最受欢迎的几种型号汽车

使用手册会介绍汽车的每一项功能， 因此不同型号的汽车， 其使用手册内容也不一样，因此需要另外一个生成器对象来专门编写使用手册。 该类与其制造汽车的兄弟类都实现了相同的制造方法， 但是其功能不是制造汽车部件， 而是描述每个部件。 将这些生成器传递给相同的主管对象， 我们就能够生成一辆汽车或是一本使用手册了。

```
// 只有当产品较为复杂且需要详细配置时，使用生成器模式才有意义。下面的两个
// 产品尽管没有同样的接口，但却相互关联。
class Car 
    // 一辆汽车可能配备有 GPS 设备、行车电脑和几个座位。不同型号的汽车（
    // 运动型轿车、SUV 和敞篷车）可能会安装或启用不同的功能。

class Manual 
    // 用户使用手册应该根据汽车配置进行编制，并介绍汽车的所有功能。


// 生成器接口声明了创建产品对象不同部件的方法。
interface Builder 
    method reset()
    method setSeats(……)
    method setEngine(……)
    method setTripComputer(……)
    method setGPS(……)

// 具体生成器类将遵循生成器接口并提供生成步骤的具体实现。你的程序中可能会
// 有多个以不同方式实现的生成器变体。
class CarBuilder implements Builder 
    private field car:Car

    // 一个新的生成器实例必须包含一个在后续组装过程中使用的空产品对象。
    constructor CarBuilder() 
        this.reset()

    // reset（重置）方法可清除正在生成的对象。
    method reset() 
        this.car = new Car()

    // 所有生成步骤都会与同一个产品实例进行交互。
    method setSeats(……) 
        // 设置汽车座位的数量。

    method setEngine(……) 
        // 安装指定的引擎。

    method setTripComputer(……) 
        // 安装行车电脑。

    method setGPS(……) 
        // 安装全球定位系统。

    // 具体生成器需要自行提供获取结果的方法。这是因为不同类型的生成器可能
    // 会创建不遵循相同接口的、完全不同的产品。所以也就无法在生成器接口中
    // 声明这些方法（至少在静态类型的编程语言中是这样的）。
    //
    // 通常在生成器实例将结果返回给客户端后，它们应该做好生成另一个产品的
    // 准备。因此生成器实例通常会在 `getProduct（获取产品）`方法主体末尾
    // 调用重置方法。但是该行为并不是必需的，你也可让生成器等待客户端明确
    // 调用重置方法后再去处理之前的结果。
    method getProduct():Car 
        product = this.car
        this.reset()
        return product

// 生成器与其他创建型模式的不同之处在于：它让你能创建不遵循相同接口的产品。
class CarManualBuilder implements Builder 
    private field manual:Manual

    constructor CarManualBuilder() 
        this.reset()

    method reset() 
        this.manual = new Manual()

    method setSeats(……) 
        // 添加关于汽车座椅功能的文档。

    method setEngine(……) 
        // 添加关于引擎的介绍。

    method setTripComputer(……) 
        // 添加关于行车电脑的介绍。

    method setGPS(……) 
        // 添加关于 GPS 的介绍。

    method getProduct():Manual 
        // 返回使用手册并重置生成器。


// 主管只负责按照特定顺序执行生成步骤。其在根据特定步骤或配置来生成产品时
// 会很有帮助。由于客户端可以直接控制生成器，所以严格意义上来说，主管类并
// 不是必需的。
class Director 
    // 主管可同由客户端代码传递给自身的任何生成器实例进行交互。客户端可通
    // 过这种方式改变最新组装完毕的产品的最终类型。主管可使用同样的生成步
    // 骤创建多个产品变体。
    method constructSportsCar(builder: Builder) i
        builder.reset()
        builder.setSeats(2)
        builder.setEngine(new SportEngine())
        builder.setTripComputer(true)
        builder.setGPS(true)

    method constructSUV(builder: Builder) 
        // ……


// 客户端代码会创建生成器对象并将其传递给主管，然后执行构造过程。最终结果
// 将需要从生成器对象中获取。
class Application 

    method makeCar() 
        director = new Director()

        CarBuilder builder = new CarBuilder()
        director.constructSportsCar(builder)
        Car car = builder.getProduct()

        CarManualBuilder builder = new CarManualBuilder()
        director.constructSportsCar(builder)

        // 最终产品通常需要从生成器对象中获取，因为主管不知晓具体生成器和
        // 产品的存在，也不会对其产生依赖。
        Manual manual = builder.getProduct()

```




# 应用场景

使用生成器模式可避免 “重叠构造函数 （telescoping constructor）” 的出现。
使用代码创建不同形式的产品 （例如石头或木头房屋）时， 可使用生成器模式
使用生成器构造组合树或其他复杂对象。

# 实现
1. 清晰地定义通用步骤， 确保它们可以制造所有形式的产品。
2. 在基本生成器接口中声明这些步骤
3. 为每个形式的产品创建具体生成器类， 并实现其构造步骤
4. 考虑创建主管类。 它可以使用同一生成器对象来封装多种构造产品的方式
5. 客户端代码会同时创建生成器和主管对象


# 优缺点
1. 可以分步创建对象， 暂缓创建步骤或递归运行创建步骤
2. 生成不同形式的产品时， 你可以复用相同的制造代码
3. 单一职责原则。 你可以将复杂构造代码从产品的业务逻辑中分离出来
4. 由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加
